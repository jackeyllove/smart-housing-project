# -*- coding: utf-8 -*-
"""mysql.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vwsEWTD0W5tKTSQYulo_J4eHWa8ByK0u
"""

import pandas as pd
import sqlite3
import json

#build mysql metadata table
#db = sqlite3.connect('database.db')#set up cloud mysql database
db = sqlite3.connect('database.db', check_same_thread=False)
cur = db.cursor()#cur to give command to database
#table storing unique id and file name
db.execute("CREATE TABLE metadata (id INTEGER primary key, name TEXT)")
#table storing parent and child dir
db.execute("CREATE TABLE relationship (parent INTEGER, child INTEGER, primary key (parent, child))")
db.execute("CREATE TABLE partitionLoc (id INTEGER, loc)")
db.execute("INSERT INTO metadata VALUES (1,'root')") # root dir

#db.execute('SELECT name FROM sqlite_master WHERE type = "table"').fetchall()

#db.execute("INSERT INTO metadata VALUES (2,'hello.txt')")
#db.execute("INSERT INTO metadata VALUES (3,'user')")

#db.execute("INSERT INTO metadata VALUES (4,'jhon')")
#db.execute("INSERT INTO metadata VALUES (5,'mary')")

#db.execute("INSERT INTO relationship VALUES(1,2)")
#db.execute("INSERT INTO relationship VALUES(1,3)")

#db.execute("INSERT INTO relationship VALUES(3,4)")
#db.execute("INSERT INTO relationship VALUES(3,5)")

def is_correct_path(path):
  if path == "/":
    return True
  if path[-1] == '/':
    print('Invalid input syntax!')
    return False
  split_path = path.split("/")
  #meta_name_list = db.execute("SELECT name FROM metadata").fetchall()
  for i in range(1, len(split_path)):
    if i == 1:
      check = db.execute("SELECT * FROM metadata WHERE name = ? AND id IN (SELECT child FROM relationship WHERE parent = 1)",(split_path[i],)).fetchall()
      if len(check) is 0:
        print("Invalid path! " + split_path[i] + " not exist!")
        return False
    else:
      parent_id = db.execute("SELECT id FROM metadata WHERE name = ?", (split_path[i - 1],)).fetchall()
      check = db.execute("SELECT * FROM metadata WHERE name = ? AND id IN (SELECT child FROM relationship WHERE parent = ?)", (split_path[i], parent_id[0][0])).fetchall()
      if len(check) is 0:
        print("Invalid path! " + split_path[i] + " not exist!")
        return False
  return True

def ls (path):
  if is_correct_path(path):
    if path == '/':
      doc = db.execute("SELECT name FROM metadata WHERE id IN (SELECT child FROM relationship WHERE parent = 1)").fetchall()
      if len(doc) == 0:
        return doc
      else:
        count = 0
        for i in doc:
          doc[count] = i[0]
          count = count + 1
        return doc
    else:
      split_path = path.split('/')
      dir = db.execute("SELECT id FROM metadata WHERE name = ?", (split_path[-1],)).fetchall()[0][0]
      doc = db.execute("SELECT name FROM metadata WHERE id IN (SELECT child FROM relationship WHERE parent = ?)", (dir,)).fetchall()
      if len(doc) == 0:
        return doc
      else:
        count = 0
        for i in doc:
          doc[count] = i[0]
          count = count + 1
        return doc
  else:
    return 'invalid path!'

def mkdir(path):
  #find last '/' index
  index = 0
  for i in range(1, len(path)):
    if path[-i] == '/':
      index = len(path) - i
      break
  new_path = path[:index]
  split_path = path.split('/')
  if new_path is '':
    file_list = db.execute("SELECT name FROM metadata WHERE id IN (SELECT child From relationship WHERE  parent = 1)").fetchall()
    count = 0
    for i in file_list:
      file_list[count] = i[0]
      count = count + 1
    if split_path[-1] in file_list:
      return 'directory '+ split_path[-1] + ' already exist!'
    else:
      dir_id = db.execute("SELECT MAX(id) from metadata").fetchall()[0][0] + 1
      db.execute("INSERT INTO metadata VALUES (?,?)",(dir_id, split_path[-1]))
      db.execute("INSERT INTO relationship VALUES (1,?)", (dir_id,))
      return 'done'
  else:
    if is_correct_path(new_path):
      parent_id = db.execute("SELECT id FROM metadata WHERE name = ?", (split_path[-2],)).fetchall()[0][0]
      file_list = db.execute("SELECT name FROM metadata WHERE id IN (SELECT child From relationship WHERE  parent =?)",(parent_id,)).fetchall()
      count = 0
      for i in file_list:
        file_list[count] = i[0]
        count = count + 1
      if split_path[-1] in file_list:
        return 'directory '+ split_path[-1] + ' already exist!'
      else:
        dir_id = db.execute("SELECT MAX(id) from metadata").fetchall()[0][0] + 1
        db.execute("INSERT INTO metadata VALUES (?,?)",(dir_id, split_path[-1]))
        db.execute("INSERT INTO relationship VALUES (?,?)", (parent_id,dir_id))
        return 'done'

def put(file, path, k):
  check = db.execute("SELECT name From metadata").fetchall()
  curr = 0
  for i in check:
    check[curr] = i[0]
    curr = curr + 1
  if file in check:
    return file + ' already exist in db system! Invalid input!'
  if is_correct_path(path):
    if path is '/':
      file_list = db.execute("SELECT name FROM metadata WHERE id IN (SELECT child From relationship WHERE  parent = 1)").fetchall()
      count = 0
      for i in file_list:
        file_list[count] = i[0]
        count = count + 1
      if file in file_list:
        return 'file '+ file + ' already exist in "/" directory!'
      else:
        dir_id = db.execute("SELECT MAX(id) from metadata").fetchall()[0][0] + 1
        db.execute("INSERT INTO metadata VALUES (?,?)",(dir_id, file))
        db.execute("INSERT INTO relationship VALUES (1,?)", (dir_id,))

        #insert partition files
        df = pd.read_csv(file)
        partition_size = (len(df.index))//k
        start_index = 0
        partition_name = file.split('.')[0]
        for i in range(1, k):
          db.execute("INSERT INTO partitionLoc VALUES (?,?)", (dir_id, partition_name + str(i)))
          stop_index = start_index + partition_size - 1
          partition_file = df.loc[start_index:stop_index]
          partition_file.to_sql(name = partition_name + str(i), con = db, index = False)
          start_index = stop_index + 1
        db.execute("INSERT INTO partitionLoc VALUES (?,?)", (dir_id, partition_name + str(k)))
        partition_file = df.loc[start_index:]
        partition_file.to_sql(name = partition_name + str(k), con = db, index = False)
        return 'done'
    else:
      split_path = path.split('/')
      parent_id = db.execute("SELECT id FROM metadata WHERE name = ?", (split_path[-1],)).fetchall()[0][0]
      file_list = db.execute("SELECT name FROM metadata WHERE id IN (SELECT child From relationship WHERE  parent =?)",(parent_id,)).fetchall()
      count = 0
      for i in file_list:
        file_list[count] = i[0]
        count = count + 1
      if file in file_list:
        return 'file '+ file + ' already exist in ' + split_path[-1] + '!'
      else:
        dir_id = db.execute("SELECT MAX(id) from metadata").fetchall()[0][0] + 1
        db.execute("INSERT INTO metadata VALUES (?,?)",(dir_id, file))
        db.execute("INSERT INTO relationship VALUES (?,?)", (parent_id,dir_id))

        #insert partition files
        df = pd.read_csv(file)
        partition_size = (len(df.index))//k
        start_index = 0
        partition_name = file.split('.')[0]
        for i in range(1, k):
          db.execute("INSERT INTO partitionLoc VALUES (?,?)", (dir_id, partition_name + str(i)))
          stop_index = start_index + partition_size - 1
          partition_file = df.loc[start_index:stop_index]
          partition_file.to_sql(name = partition_name + str(i), con = db, index = False)
          start_index = stop_index + 1
        db.execute("INSERT INTO partitionLoc VALUES (?,?)", (dir_id, partition_name + str(k)))
        partition_file = df.loc[start_index:]
        partition_file.to_sql(name = partition_name + str(k), con = db, index = False)
        return 'done'

put('Final_Housing.csv','/user/jhon',10)

ls('/user')

def rm(path):
  #find last '/' index
  index = 0
  for i in range(1, len(path)):
    if path[-i] == '/':
      index = len(path) - i
      break
  new_path = path[:index]
  file = path.split('/')[-1]
  if new_path is '':
      file_list = db.execute("SELECT name FROM metadata WHERE id IN (SELECT child From relationship WHERE  parent = 1)").fetchall()
      count = 0
      for i in file_list:
        file_list[count] = i[0]
        count = count + 1
      if file not in file_list:
        return 'file not exist, invalid input!'
      else:
        file_id = db.execute("SELECT id From metadata WHERE name = ? AND id IN(SELECT child FROM relationship WHERE parent = 1)", (file,)).fetchall()[0][0]
        loc_list = db.execute("SELECT loc FROM partitionLoc WHERE id = ?", (file_id,)).fetchall()
        for i in loc_list:
          db.execute("DROP TABLE " + str(i[0]))
        db.execute("DELETE FROM partitionLoc WHERE id = ?", (file_id,))
        db.execute("DELETE FROM metadata WHERE id = ?", (file_id,))
        db.execute("DELETE FROM relationship WHERE child = ?", (file_id,))
        return file + ' remove successfully!'
  else:
    if is_correct_path(new_path):
      split_new_path = new_path.split('/')
      parent_id = db.execute("SELECT id FROM metadata WHERE name = ?", (split_new_path[-1],)).fetchall()[0][0]
      file_list = db.execute("SELECT name FROM metadata WHERE id IN (SELECT child From relationship WHERE  parent =?)",(parent_id,)).fetchall()
      count = 0
      for i in file_list:
        file_list[count] = i[0]
        count = count + 1
      if file not in file_list:
        return 'file not exist, invalid input!'
      else:
        file_id = db.execute("SELECT id From metadata WHERE name = ? AND id IN(SELECT child FROM relationship WHERE parent = ?)", (file, parent_id)).fetchall()[0][0]
        loc_list = db.execute("SELECT loc FROM partitionLoc WHERE id = ?", (file_id,)).fetchall()
        for i in loc_list:
          db.execute("DROP TABLE " + str(i[0]))
        db.execute("DELETE FROM partitionLoc WHERE id = ?", (file_id,))
        db.execute("DELETE FROM metadata WHERE id = ?", (file_id,))
        db.execute("DELETE FROM relationship WHERE child = ?", (file_id,))
        return file + ' remove successfully!'

def readPartition(file, partition_number):
  check = db.execute("SELECT name From metadata").fetchall()
  curr = 0
  for i in check:
    check[curr] = i[0]
    curr = curr + 1
  if file not in check:
    print(file + ' is not in db! Invalid input!')
    return pd.DataFrame()
  file_id = db.execute("SELECT id FROM metadata WHERE name = ?",(file,)).fetchall()[0][0]
  partition_count = db.execute("SELECT COUNT(id) from partitionLoc where id = ?",(file_id,)).fetchall()[0][0]
  if partition_number > partition_count:
    print("Invalid number of partition number!")
    return df.DataFrame()
  elif partition_count == 0:
    df = pd.DataFrame()
    return df
  else:
    partition_loc = db.execute("SELECT loc FROM partitionLoc WHERE id =?", (file_id,)).fetchall()
    partition_doc = pd.read_sql("SELECT * FROM " + partition_loc[partition_number-1][0], db)
    return partition_doc

readPartition('Final_Housing.csv', 3)

def cat(file):
  check = db.execute("SELECT name From metadata").fetchall()
  curr = 0
  for i in check:
    check[curr] = i[0]
    curr = curr + 1
  if file not in check:
    print(file + ' is not in db! Invalid input!')
    return df.DataFrame()
  file_id = db.execute("SELECT id FROM metadata WHERE name = ?",(file,)).fetchall()[0][0]
  df = pd.DataFrame()
  partition_loc = db.execute("SELECT loc FROM partitionLoc WHERE id =?", (file_id,)).fetchall()
  for i in range(len(partition_loc)):
    temp_df = pd.read_sql("SELECT * FROM " + partition_loc[i][0], db)
    df = pd.concat([df, temp_df], axis = 0)
    df_out = df.style.hide_index()
  return df_out



def getPartitionLocations(file):
  check = db.execute("SELECT name From metadata").fetchall()
  curr = 0
  for i in check:
    check[curr] = i[0]
    curr = curr + 1
  if file not in check:
    print(file + ' is not in db! Invalid input!')
    return []
  file_id = db.execute("SELECT id FROM metadata WHERE name = ?",(file,)).fetchall()[0][0]
  partition_count = db.execute("SELECT COUNT(id) from partitionLoc where id = ?",(file_id,)).fetchall()[0][0]
  partition_loc = db.execute("SELECT loc FROM partitionLoc WHERE id =?", (file_id,)).fetchall()
  result = []
  for i in range(partition_count):
    result.append(partition_loc[i][0])
  return result
